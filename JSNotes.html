<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Understanding JavaScript Concepts</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        padding: 20px;
        max-width: 800px;
        margin: 0 auto;
      }

      h1 {
        color: #007bff;
      }

      p {
        margin-bottom: 20px;
      }

      code {
        background-color: #f7f7f7;
        padding: 2px 5px;
        border-radius: 4px;
      }

      .box {
        width: 100px;
        height: 100px;
        cursor: pointer;
      }

      #btn {
        position: fixed;
        top: 0;
        right: 16px;
        border-radius: 12px solid green;
      }
    </style>
  </head>
  <body>
    <div>
      <button class="dark-mode" id="btn">Click Me</button>
    </div>
    <h1>Understanding JavaScript Concepts</h1>

    <p>
      <strong>Parameters and Arguments:</strong> Parameters are the placeholders
      or variables defined in the function's declaration. They are used to
      specify the inputs or data that a function expects to receive when it is
      called. Arguments, on the other hand, are the actual values passed to a
      function when it is called. They are the concrete values that fill in the
      placeholders (parameters) of a function.
    </p>

    <p>For example, consider this function declaration with two parameters:</p>

    <code> function addNumbers(a, b) { return a + b; } </code>

    <p>
      In this case, <code>a</code> and <code>b</code> are the parameters of the
      <code>addNumbers</code> function. They define the inputs that the function
      expects. However, when you define parameters, you don't provide specific
      values; they are just placeholders.
    </p>

    <p>When calling the function with arguments:</p>

    <code> var result = addNumbers(2, 3); </code>

    <p>
      In this case, <code>2</code> and <code>3</code> are the arguments passed
      to the <code>addNumbers</code> function. The function will use these
      actual values to perform the addition and return the result.
    </p>

    <p>
      <strong>Implicit Return in Functions:</strong> When a function does not
      have a <code>return</code> statement, it is said to have an implicit or
      default return value of <code>undefined</code>. This means that if you
      call the function and try to capture its result in a variable, that
      variable will hold the value <code>undefined</code>.
    </p>

    <p>For example:</p>

    <code>
      function greet(name) { console.log("Hello, " + name + "!"); // The
      function does not have a 'return' statement }
    </code>

    <code>
      var greeting = greet("Alice"); console.log(greeting); // Output: undefined
    </code>

    <p>
      Even though the <code>greet</code> function doesn't return anything
      explicitly, JavaScript automatically assigns the value
      <code>undefined</code> to the variable <code>greeting</code> when we try
      to capture the result of the function call.
    </p>

    <p>
      <strong>The forEach Method:</strong> The forEach method is used in
      JavaScript to iterate over the elements of an array or any iterable object
      and perform a specific action or operation on each element. It provides a
      convenient and expressive way to loop through the elements without the
      need for explicit indexing or maintaining a separate counter variable.
    </p>

    <p>Here's an example that demonstrates the usage of forEach:</p>

    <code>
      var numbers = [1, 2, 3, 4, 5]; numbers.forEach(function(number) {
      console.log(number); });
    </code>

    <p>
      In this example, <code>forEach</code> is called on the
      <code>numbers</code> array. It takes a callback function as an argument,
      which will be executed for each element of the array. The callback
      function receives the current element as its parameter, and in this case,
      we simply log each element to the console.
    </p>

    <p>
      The <code>forEach</code> method offers a concise and readable way to
      perform operations on each element of an array without the need for an
      explicit loop. It is often used when you want to perform the same action
      for every element in an array, such as updating UI elements, manipulating
      data, or performing calculations.
    </p>

    <p>
      <strong>Event Target:</strong> In JavaScript, the (event) part you
      mentioned is about something called an "event." An event is like a signal
      that tells the computer that something happened, like a button click, a
      mouse movement, or a key press. So, the (event) is the information about
      what event occurred.
    </p>

    <p>
      Now, when you put the (event) inside a function, it's like telling the
      computer to do something specific whenever that particular event happens.
      For example, you might say, "When the user clicks this button (the event),
      I want you to show a message on the screen" (the function).
    </p>

    <p>
      So, in short, a function (event) is a set of instructions that the
      computer follows when a specific event happens. It's like having a little
      helper inside the computer that knows exactly what to do when certain
      things occur, making your programs interactive and responsive.
    </p>

    <p>
      <strong>Event Bubbling:</strong> Event bubbling is a behavior in
      JavaScript where an event that occurs on a particular element will also
      trigger the same event on its parent elements, all the way up to the
      topmost or outermost element in the document.
    </p>

    <p>
      Imagine you have a set of nested boxes inside each other, like a set of
      Russian nesting dolls. Each box represents an element on a web page, like
      a button, a paragraph, or a div.
    </p>

    <p>
      Now, let's say you click on the innermost box (the smallest one). The
      click event that happens on that inner box doesn't just affect that box
      alone; it "bubbles up" to its parent box (the one that contains it). The
      same click event is triggered on the parent box as well. Then, it
      continues to bubble up to the next parent box, and so on, until it reaches
      the topmost box (the outermost element of the page).
    </p>

    <p>
      Event bubbling allows events to affect multiple elements at once, starting
      from the innermost element and propagating to the outermost element.
    </p>

    <p>
      <strong>Object Destructuring:</strong> Object destructuring is a way to
      selectively unpack specific data from an object and use it in your code
      without having to access the object's properties using dot notation
      repeatedly.
    </p>

    <p>For example:</p>

    <code>
      // Let's say we have an object representing a student const student = {
      name: 'John', age: 20, grade: 'A', address: '123 Main St', }; // Using
      object destructuring, we can extract specific data from the student object
      const { name, age } = student; // Now, we have two new variables named
      'name' and 'age' that hold the extracted data console.log(name); //
      Output: John console.log(age); // Output: 20
    </code>

    <p>
      In this example, object destructuring allows us to create two new
      variables, <code>name</code> and <code>age</code>, which directly hold the
      values extracted from the <code>student</code> object. It makes the code
      more concise and easier to read.
    </p>

    <p>
      <strong>Async Functions and Promises:</strong> Async functions are a
      special type of function in JavaScript that allow you to work with
      asynchronous tasks in a more synchronous-looking manner. They make use of
      promises, which are objects that represent the eventual completion (or
      failure) of an asynchronous operation and its resulting value.
    </p>

    <p>
      Here's an example of an async function that fetches user data from a
      server:
    </p>

    <code>
      async function fetchUserData() { // Simulating fetching data from a
      server, which takes some time const response = await
      fetch('https://api.example.com/users'); const data = await
      response.json(); return data; } // Calling the async function async
      function main() { try { const userData = await fetchUserData();
      console.log(userData); // The rest of your code that depends on the
      fetched data can go here } catch (error) { console.error('Error fetching
      data:', error); } } main();
    </code>

    <p>
      In this example, <code>fetchUserData</code> is an async function that
      fetches user data from a server using the <code>fetch</code> API. It uses
      the <code>await</code> keyword to wait for the asynchronous tasks (such as
      fetching data and parsing JSON) to complete before proceeding with the
      code.
    </p>

    <p>
      The <code>main</code> function calls <code>fetchUserData</code> and
      handles the result. If the fetch operation is successful, the fetched user
      data will be logged to the console. If there's an error during the fetch
      operation, the <code>catch</code> block will handle it and log an error
      message.
    </p>

    <p>
      Async functions and promises make working with asynchronous operations in
      JavaScript more readable and maintainable.
    </p>

    <p>
      <strong>Hoisting:</strong> Hoisting is a behavior in JavaScript where
      variable and function declarations are moved to the top of their
      respective scopes during the compilation phase, allowing you to use them
      before they are actually declared in the code.
    </p>

    <p>For example:</p>

    <code>
      console.log(x); // Output: undefined (variable declaration is hoisted) var
      x = 5; // Variable assignment is not hoisted console.log(x); // Output: 5
      (variable)
    </code>

    <p>
      In this example, the declaration <code>var x;</code> is hoisted to the
      top, which is why the first <code>console.log(x)</code> shows
      <code>undefined</code>. The assignment <code>x = 5;</code> remains in the
      same place, so the second <code>console.log(x)</code> shows
      <code>5</code>.
    </p>

    <p>
      It's important to note that hoisting only moves the declarations, not the
      initializations (assignments). Variables are initialized with the value
      <code>undefined</code> by default until they are assigned a value later in
      the code.
    </p>

    <p>
      Hoisting can be a bit tricky to understand at first, but once you grasp
      the concept, you can use it effectively to organize your code and
      understand how JavaScript behaves during the execution of your programs.
    </p>

    <p>
      <strong>let and Hoisting:</strong> When you use <code>let</code> to
      declare a variable, hoisting still occurs, but the variable is not
      initialized (assigned a value) until the line where it is declared. This
      means that the variable exists but holds the value
      <code>undefined</code> until the assignment happens.
    </p>

    <code>
      console.log(x); // Output: ReferenceError: Cannot access 'x' before
      initialization let x = 5; console.log(x); // Output: 5
    </code>

    <p>
      In this example, <code>let x</code> is hoisted to the top, but the
      assignment <code>x = 5</code> remains in the same place. Trying to access
      <code>x</code> before it's initialized results in a
      <code>ReferenceError</code>.
    </p>

    <p><strong>The .then Method and Asynchronous Programming:</strong></p>

    <p>
      In asynchronous programming, the <code>.then</code> method is typically
      chained onto a promise and takes one or two callback functions as
      arguments. The first callback function is executed when the promise is
      fulfilled, i.e., when the asynchronous operation is successful. The second
      callback function (optional) is executed when the promise is rejected,
      i.e., when the asynchronous operation encounters an error.
    </p>

    <code>
      fetch('https://api.example.com/data') .then(response => response.json())
      .then(data => console.log(data)) .catch(error => console.log(error));
    </code>

    <p>
      In this example, we use the <code>fetch</code> function to make an HTTP
      request to retrieve data from the specified URL. The
      <code>fetch</code> function returns a promise that resolves with a
      Response object. We chain the <code>.then</code> method to the promise and
      provide a callback function that converts the response to JSON using the
      <code>json</code> method of the Response object.
    </p>

    <p>
      The first <code>.then</code> callback is executed with the JSON data as
      the argument. We log the data to the console. If there are subsequent
      <code>.then</code> methods chained, the output of one
      <code>.then</code> will be passed as the input to the next
      <code>.then</code>.
    </p>

    <p>
      In summary, the <code>.then</code> method is used with promises to handle
      the successful fulfillment of a promise and receive the result of the
      asynchronous operation. It allows you to chain multiple asynchronous
      operations together, executing them sequentially.
    </p>

    <p>
      The <code>json()</code> method is a built-in method available on the
      Response object returned by the <code>fetch()</code> function or other
      network requests. This method is used to extract the JSON data from the
      response body.
    </p>

    <h2>Asynchronous Programming</h2>

    <p>
      <strong>Responsiveness:</strong> Asynchronous operations allow your
      program to continue executing other tasks while waiting for a
      time-consuming operation to complete. This prevents blocking the execution
      and keeps your application responsive. For example, in a web application,
      asynchronous programming allows the user interface to remain interactive
      while fetching data from a server.
    </p>

    <p>
      <strong>Efficiency:</strong> Asynchronous programming enables efficient
      utilization of system resources. While one operation is waiting for I/O
      (input/output) or network requests to complete, other operations can
      execute concurrently. This maximizes the efficiency of your program and
      improves overall performance.
    </p>

    <h2>First-Class Functions</h2>

    <p>
      Yes, in JavaScript, functions can be treated as variables, allowing you to
      assign them to variables, pass them as arguments to other functions, or
      even return them from other functions. This concept is known as
      "first-class functions."
    </p>

    <p>
      Here are some examples to illustrate how functions can be used as
      variables:
    </p>

    <code>
      const myFunction = function() { console.log("Hello, world!"); }; // Call
      the function through the variable myFunction(); // Output: Hello, world!
    </code>

    <p>
      In this example, the <code>myFunction</code> variable is assigned an
      anonymous function. You can then call the function using the variable name
      followed by parentheses.
    </p>

    <p>
      <strong>Passing a Function as an Argument to Another Function:</strong>
    </p>

    <code>
      function executeFunction(func) { func(); } function sayHello() {
      console.log("Hello!"); } // Pass the sayHello function as an argument
      executeFunction(sayHello); // Output: Hello
    </code>

    <p>
      Here, we have a function <code>executeFunction</code> that takes another
      function <code>func</code> as an argument. When we call
      <code>executeFunction(sayHello)</code>, the <code>sayHello</code> function
      is passed as an argument to <code>executeFunction</code> and then executed
      inside <code>executeFunction</code> using <code>func()</code>.
    </p>

    <p>
      This pattern is commonly used in JavaScript for callback functions, where
      you pass a function as an argument to another function and that function
      will call the passed function at a specific point in time or in response
      to an event.
    </p>

    <h2>Returning a Function from Another Function</h2>

    <code>
      function createGreeter(name) { return function() { console.log("Hello, " +
      name + "!"); }; } const greetJohn = createGreeter("John"); const greetJane
      = createGreeter("Jane"); greetJohn(); // Output: Hello, John! greetJane();
      // Output: Hello, Jane!
    </code>

    <p>
      In this example, the <code>createGreeter</code> function returns an
      anonymous function that takes no arguments. The returned function captures
      the <code>name</code> parameter from the outer function's scope, allowing
      you to create multiple greeter functions with different names.
    </p>

    <h2>Context of 'this' Keyword</h2>

    <p>
      <strong>Constructor Functions:</strong> When a function is used as a
      constructor function (invoked with the <code>new</code> keyword to create
      an instance), <code>this</code> refers to the newly created object.
    </p>

    <code>
      function Person(name) { this.name = name; } const john = new
      Person("John"); console.log(john.name); // Output: John
    </code>

    <p>
      In this example, <code>john</code> is an instance of the
      <code>Person</code> constructor function. When
      <code>new Person("John")</code> is called, a new object is created with
      the property <code>name</code> set to "John," and <code>this</code> refers
      to that newly created object inside the constructor function.
    </p>

    <p>
      <strong>Event Handlers:</strong> In event handler functions, such as those
      used with DOM events, <code>this</code> typically refers to the element
      that triggered the event.
    </p>

    <code>
      const button = document.querySelector("button");
      button.addEventListener("click", function() { console.log(this); //
      Output: <button>...</button>
      });
    </code>

    <p>
      In this example, the event handler function is triggered when the
      <code>button</code> element is clicked, so <code>this</code> refers to the
      <code>button</code> element inside the event handler function.
    </p>

    <p>
      <strong>Methods:</strong> In object methods, <code>this</code> refers to
      the object itself, allowing you to access other properties and methods of
      the object.
    </p>

    <code>
      const person = { name: "John", greet: function() { console.log("Hello, " +
      this.name + "!"); } }; person.greet(); // Output: Hello, John!
    </code>

    <p>
      In this example, <code>this</code> refers to the
      <code>person</code> object inside the <code>greet</code> method, allowing
      us to access the <code>name</code> property of the object using
      <code>this.name</code>.
    </p>

    <p>
      However, it's essential to note that the context of <code>this</code> can
      be influenced by how a function is called, and it can behave differently
      in various situations. Arrow functions, for example, do not have their own
      <code>this</code> context and instead lexically capture the
      <code>this</code> value from their surrounding code.
    </p>

    <h2>Spread Operator</h2>

    <p>
      The spread operator is a powerful feature introduced in ECMAScript 6 that
      allows you to "spread" the elements of an iterable (e.g., an array or a
      string) into individual elements. It is denoted by the three dots (...).
    </p>

    <p><strong>Spread with Arrays:</strong></p>

    <code>
      const arr = [1, 2, 3]; const newArr = [...arr, 4, 5]; console.log(newArr);
      // Output: [1, 2, 3, 4, 5]
    </code>

    <p>
      In this example, the spread operator <code>...</code> is used to spread
      the elements of the <code>arr</code> array into individual elements. These
      elements are then used to create a new array <code>newArr</code> along
      with additional elements <code>4</code> and <code>5</code>.
    </p>

    <p><strong>Spread with Objects:</strong></p>

    <code>
      const obj1 = { x: 1, y: 2 }; const obj2 = { z: 3 }; const mergedObj = {
      ...obj1, ...obj2 }; console.log(mergedObj); // Output: { x: 1, y: 2, z: 3
      }
    </code>

    <p>
      Similarly, the spread operator can be used with objects to merge their
      properties into a new object.
    </p>

    <h2>CSS Flexbox</h2>

    <p>
      CSS Flexbox is a layout model that provides a flexible way to distribute
      and align items within a container, whether it's a row or a column.
      Flexbox is especially useful for creating responsive and dynamic layouts.
    </p>

    <p>
      <strong>Flex Container:</strong> To use Flexbox, you need to designate a
      parent element as a flex container by applying the
      <code>display: flex</code> or <code>display: inline-flex</code> property
      to it.
    </p>

    <code>
      .flex-container { display: flex; /* or display: inline-flex; */ }
    </code>

    <p>
      <strong>Flex Items:</strong> The direct children of the flex container are
      called flex items. These elements will be laid out within the container
      based on the flex properties you apply to them.
    </p>

    <p>
      <strong>Flex Direction:</strong> The <code>flex-direction</code> property
      defines the primary axis along which the flex items are laid out. It can
      be set to either <code>row</code> (horizontal) or
      <code>column</code> (vertical).
    </p>

    <code>
      .flex-container { display: flex; flex-direction: row; /* or
      flex-direction: column; */ }
    </code>

    <p>
      <strong>Flex Justify Content:</strong> The
      <code>justify-content</code> property is used to align the flex items
      along the main axis (horizontal for <code>row</code> and vertical for
      <code>column</code>).
    </p>

    <code>
      .flex-container { display: flex; justify-content: center; /* or
      flex-start, flex-end, space-between, space-around, space-evenly */ }
    </code>

    <p>
      <strong>Flex Align Items:</strong> The <code>align-items</code> property
      is used to align the flex items along the cross axis (horizontal for
      <code>row</code> and vertical for <code>column</code>).
    </p>

    <code>
      .flex-container { display: flex; align-items: center; /* or flex-start,
      flex-end, stretch, baseline */ }
    </code>

    <p>
      These are just some of the basic properties of CSS Flexbox. Flexbox offers
      many other powerful features for creating sophisticated layouts with ease.
      It's widely supported in modern browsers and is a popular choice for
      building responsive web designs.
    </p>

    <h2>Block Scope in JavaScript</h2>

    <p>
      Block scope refers to the area within a program where variables are only
      accessible within the block in which they are defined. In JavaScript,
      variables declared with the <code>let</code> and
      <code>const</code> keywords have block scope.
    </p>

    <p>Let's take a look at an example:</p>

    <code>
      function blockScopeExample() { if (true) { // Block scope variable let
      blockVar = "I am a block variable"; const anotherBlockVar = "I am another
      block variable"; console.log(blockVar); // Output: "I am a block variable"
      console.log(anotherBlockVar); // Output: "I am another block variable" }
      // Trying to access the block variables from outside the block (will
      result in an error) console.log(blockVar); // Error: blockVar is not
      defined console.log(anotherBlockVar); // Error: anotherBlockVar is not
      defined } blockScopeExample();
    </code>

    <p>
      In this example, we have a function called
      <code>blockScopeExample</code> that demonstrates block scope. Inside the
      function, we have an <code>if</code> statement that creates a block.
      Within this block, we declare two variables using <code>let</code> and
      <code>const</code>. These variables, <code>blockVar</code> and
      <code>anotherBlockVar</code>, are accessible only within the block, and
      any attempt to access them outside the block will result in an error.
    </p>

    <p>
      This behavior is different from variables declared with <code>var</code>,
      which have function scope or global scope and can be accessed outside the
      block where they are defined.
    </p>

    <h2>Function Scope in JavaScript</h2>

    <p>
      Function scope refers to the area within a program where variables are
      only accessible within the function in which they are defined. In
      JavaScript, variables declared with <code>var</code> have function scope.
    </p>

    <p>Let's take a look at an example:</p>

    <code>
      function functionScopeExample() { // Function scope variable var
      functionVar = "I am a function variable"; console.log(functionVar); //
      Output: "I am a function variable" } functionScopeExample(); // Trying to
      access the function variable from outside the function (will result in an
      error) console.log(functionVar); // Error: functionVar is not defined
    </code>

    <p>
      In this example, we have a function called
      <code>functionScopeExample</code> that demonstrates function scope. Inside
      the function, we declare a variable called <code>functionVar</code> using
      <code>var</code>. This variable is accessible only within the function,
      and any attempt to access it outside the function will result in an error.
    </p>

    <p>
      This is because variables declared with <code>var</code> are
      function-scoped, meaning they are only visible within the function where
      they are defined. They are not accessible outside the function, and their
      scope is limited to the enclosing function.
    </p>

    <h2>Local Scope and Global Scope in JavaScript</h2>

    <p>
      In JavaScript, variables can be declared with either local scope or global
      scope:
    </p>

    <h3>Local Scope:</h3>

    <p>
      Local scope refers to the scope of variables that are declared within a
      function or a block using <code>let</code> or <code>const</code>. These
      variables are only accessible within the function or block in which they
      are defined. Any attempt to access these variables outside their defining
      function or block will result in an error.
    </p>

    <code>
      function localScopeExample() { // Local scope variable let localVar = "I
      am a local variable"; const anotherLocalVar = "I am another local
      variable"; console.log(localVar); // Output: "I am a local variable"
      console.log(anotherLocalVar); // Output: "I am another local variable" }
      localScopeExample(); // Trying to access the local variables from outside
      the function (will result in an error) console.log(localVar); // Error:
      localVar is not defined console.log(anotherLocalVar); // Error:
      anotherLocalVar is not defined
    </code>

    <h3>Global Scope:</h3>

    <p>
      Global scope refers to the scope of variables that are declared outside
      any function or block, making them accessible throughout the entire
      JavaScript program. Global variables are declared using the
      <code>var</code> keyword or by attaching properties directly to the global
      object (<code>window</code> in the browser environment).
    </p>

    <code>
      // Global scope variable declared with var var globalVar = "I am a global
      variable"; function globalScopeExample() { console.log(globalVar); //
      Output: "I am a global variable" } globalScopeExample(); // Accessing the
      global variable outside the function is possible console.log(globalVar);
      // Output: "I am a global variable"
    </code>

    <p>
      It is essential to use local scope to avoid polluting the global scope
      with unnecessary variables. Global variables can be accessed and modified
      from any part of the code, which may lead to unintended consequences and
      bugs.
    </p>

    <script>
      let isClicked = true;

      function toggle() {
        if (isClicked) {
          document.body.style.background = "black";
          document.body.style.color = "red";
        } else {
          document.body.style.background = "white";
          document.body.style.color = "black";
        }

        isClicked = !isClicked;
        document.body.classList.toggle("dark");
      }

      let btn = document.querySelector(".dark-mode");
      btn.addEventListener("click", toggle);
    </script>
  </body>
</html>
